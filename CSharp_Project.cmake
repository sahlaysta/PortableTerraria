function(CSharp_Project)
    
    # Ensure the validity of the function arguments
    cmake_parse_arguments(PARSED_ARGS "" "PROJECT_NAME;PROJECT_APPLICATIONTYPE;PROJECT_APPLICATIONICON" "PROJECT_DEPENDS;PROJECT_SOURCEFILES;PROJECT_VSDOTNETREFERENCES;PROJECT_EMBEDDEDRESOURCEFILES;PROJECT_POSTBUILDCOMMANDS" ${ARGN})
    if(NOT PARSED_ARGS_PROJECT_NAME)
        message(FATAL_ERROR "Missing arg PROJECT_NAME")
    endif()
    if(NOT PARSED_ARGS_PROJECT_SOURCEFILES)
        message(FATAL_ERROR "Missing arg PROJECT_SOURCEFILES")
    endif()
    if(NOT PARSED_ARGS_PROJECT_APPLICATIONTYPE)
        message(FATAL_ERROR "Missing arg PROJECT_APPLICATIONTYPE")
    endif()
    if(PARSED_ARGS_PROJECT_APPLICATIONTYPE STREQUAL "Console")
        unset(APPLICATIONTYPE)
    elseif(PARSED_ARGS_PROJECT_APPLICATIONTYPE STREQUAL "Application")
        if(NOT DEBUGFLAG STREQUAL "ON")
            set(APPLICATIONTYPE "WIN32")
        endif()
    else()
        message(FATAL_ERROR "Invalid value for PROJECT_APPLICATIONTYPE = \"${PARSED_ARGS_PROJECT_APPLICATIONTYPE}\", expected \"Console\" or \"Application\"")
    endif()
    
    # Create the placeholder files of the embedded resources
    set(EMBEDDEDRESOURCES_COPYDIR ${CMAKE_CURRENT_BINARY_DIR}/../../embeddedresources/${PARSED_ARGS_PROJECT_NAME})
    file(REMOVE_RECURSE ${EMBEDDEDRESOURCES_COPYDIR}/)
    if(PARSED_ARGS_PROJECT_EMBEDDEDRESOURCEFILES)
        set(EMBEDDEDRESOURCE_I 1)
        foreach(EMBEDDEDRESOURCEFILE ${PARSED_ARGS_PROJECT_EMBEDDEDRESOURCEFILES})
            get_filename_component(EMBEDDEDRESOURCEFILE_FILENAME ${EMBEDDEDRESOURCEFILE} NAME)
            set(PLACEHOLDER_EMBEDDEDRESOURCE_FILE ${EMBEDDEDRESOURCES_COPYDIR}/${EMBEDDEDRESOURCE_I}/${EMBEDDEDRESOURCEFILE_FILENAME})
            file(WRITE ${PLACEHOLDER_EMBEDDEDRESOURCE_FILE} "")
            list(APPEND PLACEHOLDER_EMBEDDEDRESOURCE_FILES ${PLACEHOLDER_EMBEDDEDRESOURCE_FILE})
            MATH(EXPR EMBEDDEDRESOURCE_I "${EMBEDDEDRESOURCE_I}+1")
        endforeach()
    endif()
    
    # Now configure the main C# project
    include(CSharpUtilities)
    project(${PARSED_ARGS_PROJECT_NAME} LANGUAGES CSharp)
    add_executable(${PARSED_ARGS_PROJECT_NAME} ${APPLICATIONTYPE} ${PARSED_ARGS_PROJECT_SOURCEFILES} ${PLACEHOLDER_EMBEDDEDRESOURCE_FILES})
    set(CMAKE_CSharp_FLAGS "/langversion:latest")
    set(CMAKE_CSharp_FLAGS "/platform:x86")
    target_compile_options(${PARSED_ARGS_PROJECT_NAME} PUBLIC "/unsafe")
    if(PARSED_ARGS_PROJECT_DEPENDS)
        add_dependencies(${PARSED_ARGS_PROJECT_NAME} ${PARSED_ARGS_PROJECT_DEPENDS})
    endif()
    set_target_properties(${PARSED_ARGS_PROJECT_NAME} PROPERTIES RUNTIME_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/binout/$<IF:1,,>")
    set_property(TARGET ${PARSED_ARGS_PROJECT_NAME} PROPERTY VS_DOTNET_TARGET_FRAMEWORK_VERSION "v4.6.1")
    if(PARSED_ARGS_PROJECT_VSDOTNETREFERENCES)
        set_property(TARGET ${PARSED_ARGS_PROJECT_NAME} PROPERTY VS_DOTNET_REFERENCES ${PARSED_ARGS_PROJECT_VSDOTNETREFERENCES})
    endif()
    
    # Before build, re-copy the embedded resources to their placeholder files
    if(PARSED_ARGS_PROJECT_EMBEDDEDRESOURCEFILES)
        set(EMBEDDEDRESOURCE_I 1)
        foreach(EMBEDDEDRESOURCEFILE ${PARSED_ARGS_PROJECT_EMBEDDEDRESOURCEFILES})
            get_filename_component(EMBEDDEDRESOURCEFILE_FILENAME ${EMBEDDEDRESOURCEFILE} NAME)
            set(PLACEHOLDER_EMBEDDEDRESOURCE_FILE ${EMBEDDEDRESOURCES_COPYDIR}/${EMBEDDEDRESOURCE_I}/${EMBEDDEDRESOURCEFILE_FILENAME})
            set_property(SOURCE ${PLACEHOLDER_EMBEDDEDRESOURCE_FILE} PROPERTY VS_TOOL_OVERRIDE "EmbeddedResource")
            list(APPEND COPY_EMBEDDEDRESOURCE_COMMAND_ARGS COMMAND ${CMAKE_COMMAND} -E copy ${EMBEDDEDRESOURCEFILE} ${PLACEHOLDER_EMBEDDEDRESOURCE_FILE})
            MATH(EXPR EMBEDDEDRESOURCE_I "${EMBEDDEDRESOURCE_I}+1")
        endforeach()
        add_custom_command(OUTPUT ${PARSED_ARGS_PROJECT_NAME}_EMBEDDEDRESOURCE_COPYOUTPUT WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} ${COPY_EMBEDDEDRESOURCE_COMMAND_ARGS})
        add_custom_target(${PARSED_ARGS_PROJECT_NAME}_EMBEDDEDRESOURCE_COPYTARGET DEPENDS ${PARSED_ARGS_PROJECT_NAME}_EMBEDDEDRESOURCE_COPYOUTPUT ${PARSED_ARGS_PROJECT_DEPENDS})
        add_dependencies(${PARSED_ARGS_PROJECT_NAME} ${PARSED_ARGS_PROJECT_NAME}_EMBEDDEDRESOURCE_COPYTARGET ${PARSED_ARGS_PROJECT_DEPENDS})
    endif()
    
    # Configure the application icon
    # Before build, re-copy the icon file to a file named "icon.ico" in CMAKE_CURRENT_BINARY_DIR and configure this file as the icon
    if(PARSED_ARGS_PROJECT_APPLICATIONICON)
        set_property(TARGET ${PARSED_ARGS_PROJECT_NAME} PROPERTY VS_GLOBAL_ApplicationIcon "icon.ico")
        get_filename_component(APPLICATIONICON_ABSOLUTEPATH ${PARSED_ARGS_PROJECT_APPLICATIONICON} ABSOLUTE)
        if(NOT EXISTS ${APPLICATIONICON_ABSOLUTEPATH} OR IS_DIRECTORY ${APPLICATIONICON_ABSOLUTEPATH})
            message(FATAL_ERROR "File not found ${PARSED_ARGS_PROJECT_APPLICATIONICON}")
        endif()
        add_custom_command(OUTPUT ${PARSED_ARGS_PROJECT_NAME}_ICON_COPYOUTPUT WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} COMMAND ${CMAKE_COMMAND} -E copy "${PARSED_ARGS_PROJECT_APPLICATIONICON}" "${CMAKE_CURRENT_BINARY_DIR}/icon.ico")
        add_custom_target(${PARSED_ARGS_PROJECT_NAME}_ICON_COPYTARGET DEPENDS ${PARSED_ARGS_PROJECT_NAME}_ICON_COPYOUTPUT)
        add_dependencies(${PARSED_ARGS_PROJECT_NAME} ${PARSED_ARGS_PROJECT_NAME}_ICON_COPYTARGET)
    endif()
    
    # If specified, execute post-build commands
    if(PARSED_ARGS_PROJECT_POSTBUILDCOMMANDS)
        add_custom_command(TARGET ${PARSED_ARGS_PROJECT_NAME} POST_BUILD ${PARSED_ARGS_PROJECT_POSTBUILDCOMMANDS})
    endif()
    
endfunction()